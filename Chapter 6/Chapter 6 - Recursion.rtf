{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Chapter 6: Recursion
\b0 \
\
A recursive function is a function that calls itself.\
Functional programming favors recursion for looping rather than traditional while of for loops, in order to maintain statelessness and avoid side effects.\
\

\b Example: Factorial\

\b0 Each time a function is called, aditional space is taken up the call stack. This stack is built up so when a value is returned, the program knows where to go back.\
This might result in in an stack overflow error. \
\

\b Tail call optimization\

\b0 A tail call is a call to a function that occurs as the last action of another function.\
In certain circumstances, the interpretor can reuse the current stack frame for the function call instead of creating a new one. \
Unlike other languages, ES6 tail call optimization is implemented by the interpreter and does not have a syntax for denoting tail call optimization specified by ES6.\
In ES6, new stack frames will not be created, thus allowing for a O(1) memory complexity. \
\

\b Example: Tail call optimized factorial
\b0 \
\
{\field{\*\fldinst{HYPERLINK "https://kangax.github.io/compat-table/es6/"}}{\fldrslt https://kangax.github.io/compat-table/es6/}}\
babel-plugin-tailcall-optimization}