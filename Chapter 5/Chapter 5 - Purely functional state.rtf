{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww38200\viewh18880\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Chapter 5: Simulating state\
\

\b0 How do we write purely functional programs that manipulate state?\
We can maintain refertial transparency by making the state updates explicit.\
Instead of updating the state as a side effect, we can simply return the new state along with the new values, leaving the old state unmodified.\
The concern of computing the next state should be separated from the concern of communicating the new state to the rest of the program.\
\

\b Example: Passing state to pure functions
\b0 \
\

\b Redux
\b0 \
Predictable state container for JavaScript apps.\
The whole state of the app is stored in an object tree inside a single store. \
The only way to change the state tree is to rmit an action, an object describing what happened.\
To specify how the actions transform the state tree, use pure reducers. \
\

\b Example: Removing an element from the list
\b0 \
\
- dispatch: the only possible way to trigger a state change\
- action: plain object describing the change\
- type: required field on the action that indicates the type of action being performed}